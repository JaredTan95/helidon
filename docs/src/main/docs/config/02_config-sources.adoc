///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2018 Oracle and/or its affiliates. All rights reserved.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

:javadoc-base-url-api: {javadoc-base-url}?io/helidon/config

= 加载配置：配置源和解析器
:description: A summary of Helidon config sources and parsers
:keywords: Helidon, config, sources, parsers

可以从不同位置加载不同格式表示的配置。本节介绍应用程序如何使用配置源和配置解析器来加载配置数据。

== 总览
每个配置源从特定类型的位置读取数据，但是并不考虑那里的配置数据的格式。
每个配置解析器将以特定格式表示的数据转换为配置系统其余部分使用的内存中配置数据结构，而不关心数据所在的位置或物理检索方式。
将给定格式准备数据在给定系统的给定位置进行协同工作。
当您的应用程序准备 `Config.Builder` 时，它会设置构建器在构造生成的 `Config` 对象时应使用的 `ConfigSource` 和 `ConfigParser` 。


== 配置来源
如果您的应用程序使用默认配置，则配置系统会自动为您设置配置源，如 <<config/01_introduction.adoc#config-sources-default-config,配置简介>> 中所述。
如果您的应用程序使用 link:{javadoc-base-url-api}/Config.Builder.html[`Config.Builder`]，那么它可以调用该构建器上的某个源方法来设置它应该使用的配置源。

配置系统包括对几种配置源的支持，例如：

* 运行时类路径上的资源，
* 环境变量，
* 一份文件，
* Java系统属性，
* 一个URL，
* 各种内存数据结构 (`String`, `Map`, `Properties`)

有关内置配置源类型的完整列表以及如何使用它们，请参阅 link:{javadoc-base-url-api}/ConfigSources.html[`ConfigSources`] 类的Java文档。

您还可以通过实现 link:{javadoc-base-url-api}/spi/ConfigSource.html[`ConfigSource`] 接口来扩展配置系统以处理其他类型的源。
有关完整信息，请参阅<<config/07_extensions.adoc,扩展>>文档。

有关配置源的一些更复杂的方面的详细信息，请参阅 <<config/06_advanced-configuration.adoc,高级主题>> 页面。

== Config Parsers [[parsers]]
When it reads configuration text from sources, the config system uses config parsers 
to translate that text into the in-memory data structures representing that configuration. 
The config system includes several built-in parsers, such as for the Java properties, YAML, JSON, and HOCON formats. See <<config/01_introduction.adoc#built-in-formats,this section in
the introduction>> for
how to change your `pom.xml` to make parsers for those formats available to your 
application. Then your application can invoke the 
link:{javadoc-base-url-api}/Config.Builder.html#addParser-io.helidon.config.spi.ConfigParser-[config builder's `addParser`] method
so that builder will use the parsers you choose.

You can extend the system with custom parsers of your own. Implement the link:{javadoc-base-url-api}/spi/ConfigParser.html[`ConfigParser`] interface, then construct a `Config.Builder` using the `addParser` method, passing an instance of your customer parser. Invoke one of the `sources` methods to include a source that uses the custom format and then build the `Config` object.

== Detecting and Responding to Changes in Config Data
Each `Config` object which the config system returns to your application is
immutable; even if the information in one of the underlying config sources changes, an in-memory data structure built from the earlier
content remains unchanged.

Even so, the config system allows your application to learn when such underlying changes in the data occur and respond accordingly. The <<config/05_mutability-support.adoc,mutability>> section explains this in detail, and the link:{javadoc-base-url-api}/PollingStrategies.html[`PollingStrategies`] JavaDoc describes the built-in implementations. You can, of course, write your own by implementing the link:{javadoc-base-url-api}/spi/PollingStrategy.html[`PollingStrategy`] interface. On a config source builder invoke `pollingStrategy` with an instance of your custom strategy and then invoke `build` to create the `ConfigSource`.

== Dealing with Loading Errors: Retry Policies [[retry]]
Config sources, especially those that depend on fallible mechanisms such as the network or a shared file system, might fail to load during momentary outages. The config system allows you to build resiliency into your application's use of configuration that relies on such technologies. 

When your application builds a `ConfigSource` it can specify a _retry policy_. When the config system needs to load data from that source it delegates the load operation to that retry policy. That policy is responsible not only for loading the data but also for detecting errors during loading and implementing the algorithm for deciding when and how many times to retry a failed load before reporting a failure back to your application.

The config system includes two predefined retry policies:

.Predefined Retry Policies
|===
|Policy | Summary

|"just call" (default) |asks the config source to load the data with no retry
|"repeat" |performs a settable number of time-based retries, reporting failure only after all available retries have failed
|===

See the link:{javadoc-base-url-api}/RetryPolicies.html[`RetryPolicies`] JavaDoc for complete details on these built-in retry policies.

You can devise your own policy. Implement the link:{javadoc-base-url-api}/spi/RetryPolicy.html[`RetryPolicy`] interface. Then pass an instance of your policy implementation to the config source builder's `retryPolicy` method.

